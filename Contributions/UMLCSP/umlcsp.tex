\clearemptydoublepage
\chapter{Contribution : UML CSP}

\begin{outline}
    \item We can model Integer Collections type properties (it is possible to encode a lot of finite domain problems for different property types)
    \item This encoding works for both integer attributes and object references
    \item References has have extra "layers of models", leveraging the limited domains for pointer variables
\end{outline}

\section{Encoding Properties}
\textbf{A. Encoding Properties.}
% \ytodo{remind that properties are the generalisation of attribute and reference}
The variables represent the properties--attributes and references--of the objects in the instance.
Each class property is encoded as a matrix of integer variables, denoted $Class.property$. 
Each row in this matrix corresponds to one object of the class; for example, the $i$-th row is noted as $Class_i.property$ where $i \in [1, o]$ and $o = |Class|$ is the number of objects of that class. The number of columns $p$ in this table is derived from the property's cardinality, which is given by $n$ and $m$ from Figure~\ref{fig:metamodel}.
% The variables in our CSP represent the properties--attributes and references--of the objects of an instance.
% A property of a class is encoded as a matrix of integer variables $Class.property$.
% For each of the objects of the class, there is a row in the table,
% an array of integer variables we note $Class_{i}.property$ where $i\in[1,o]$ identifies the object and $o=|Class|$, the count of the objects of the class.
% The number of columns in the table depends on the number of variables $p$ encoding the property.
% The value of $p$ is found in the class diagram, $n$ and $m$ from Figure \ref{fig:metamodel}.
% and we can identify an individual integer variable of the property $Class_o.property_m$.
$$\mathit{Class.property} = \{x_{11},...,x_{op}\}$$
$$\forall x \in Class.property,\;domain(x) = \{d\}\cup\{lb..ub\}$$
% \begin{equation}\label{csp:seq_X2Y}
% Class.property
% \begin{cases}
% \end{cases}
% \end{equation}
Each property variable $x_{ij}$ in the matrix has a domain defined by a lower bound $lb$, an upper bound $ub$, and a special dummy value $d$, where we set $d = lb - 1$. The property type, e.g., reference or attribute, determines the specific domain bounds.
Attributes with an integer type may require large ranges, making domain enumeration impractical. This limits our ability to use certain global constraints like \inlinecstr{global\_cardinality} constraint, which counts the occurrences of domain values and therefore require finite, reasonably small domains.
\textcolor{black}{
By default we chose a 16-bit range for these values: $lb=-32768$ and $ub=32767$, meaning $d=-32769$, but these bounds can be refined by annotating the model accordingly\cite{coyle_towards_2025}.
}
%%
For reference properties, the domain is defined as $\{1, \ldots, o\} \cup \{nullptr\}$, where $o$ is the number of instances of the target class. 
These variables, named \texttt{ptr}, acts as pointers: values in $[1, o]$ identify object rows, and $0$ (i.e., dummy value \emph{nullptr}) denotes the absence of a reference. To support \emph{nullptr}, an extra row is added to each table to represent a dummy object.

% The domain of property variables (such as $x_{ij}$) has three important values: a lower bound $lb$, an upper bound $ub$, and a dummy value $d$.
% A natural choice is $d=lb-1$.
% Properties of objects come in two types as discussed in Section \ref{ssec:ctxt_cd}, either a reference or an attribute.
% The choice of $lb$ and $ub$ depends on the type of property.
% Integer type attributes can require a large range between lowest and highest possible value that isn't practical to enumerate.
% This will reveal itself as a constraint on our reformulations of OCL operations into global constraints, as they cannot rely on globals such as \inlinecstr{global\_cardinality}, which counts the occurrences of the values in the domain.
% % \ytodo{note the domain of attributes being large, we focus on reformulations dependent on the number of variables, not the number of values}
% In the case the table encodes a reference property, the domain can be set to $\{1..o\}\cup \{nullptr\}$ where $o$ is the number of  instances of the class, and generally name such variables $\mathit{ptr}$ for \emph{pointer}.
% The range $[1,o]$ identifies objects, and 0 is the dummy value that we call \emph{nullptr}.
% These variables therefore also identify rows in the $Class.property$ tables, and to handle the case of \emph{nullptr} we add a row for a \emph{dummy object}.
\begin{table}[!t]
\centering
\begin{tabular}{|lrrr|l|lrr|}
\cline{1-4} \cline{6-8}
\multicolumn{4}{|l|}{\textbf{Object.attribute}}                                                                    &  & \multicolumn{3}{l|}{\textbf{Object.reference}}                                   \\ \cline{1-4} \cline{6-8} 
\multicolumn{1}{|l|}{\textbf{$Object_i$}} & \multicolumn{3}{l|}{\textbf{attribute}}                                     &  & \multicolumn{1}{l|}{\textbf{$Object_i$}} & \multicolumn{2}{l|}{\textbf{reference}}    \\ \cline{1-4} \cline{6-8} 
\multicolumn{1}{|l|}{\textbf{0}}    & \multicolumn{1}{r|}{d}         & \multicolumn{1}{r|}{d}         & d         &  & \multicolumn{1}{l|}{\textbf{0}}    & \multicolumn{1}{r|}{nullptr}         & nullptr         \\ \cline{1-4} \cline{6-8} 
\multicolumn{1}{|l|}{\textbf{1}}    & \multicolumn{1}{r|}{-3}        & \multicolumn{1}{r|}{4}         & 6         &  & \multicolumn{1}{l|}{\textbf{1}}    & \multicolumn{1}{r|}{3}         & 2         \\ \cline{1-4} \cline{6-8} 
\multicolumn{1}{|l|}{\textbf{2}}    & \multicolumn{1}{r|}{1000}      & \multicolumn{1}{r|}{$a_{22}$} & $a_{23}$ &  & \multicolumn{1}{l|}{\textbf{2}}    & \multicolumn{1}{r|}{$ptr_{21}$} & $ptr_{22}$ \\ \cline{1-4} \cline{6-8} 
\multicolumn{1}{|l|}{\textbf{3}}    & \multicolumn{1}{r|}{-99}       & \multicolumn{1}{r|}{-33}       & $a_{33}$ &  & \multicolumn{1}{l|}{\textbf{3}}    & \multicolumn{1}{r|}{1}         & $ptr_{32}$ \\ \cline{1-4} \cline{6-8} 
% \multicolumn{1}{|l|}{\textbf{4}}    & \multicolumn{1}{r|}{$a_{41}$} & \multicolumn{1}{r|}{$a_{42}$} & $a_{43}$ &  & \multicolumn{1}{l|}{\textbf{4}}    & \multicolumn{1}{r|}{$ptr_{40}$} & $ptr_{41}$ \\ \cline{1-4} \cline{6-8} 
\end{tabular} \vspace{0.5em}
    \caption{Encoding of the instance from Figure \ref{fig:model} as tables of integer variables}
    \label{tab:encoding}
\end{table}
Table~\ref{tab:encoding} shows the encoding of the instance from Figure~\ref{fig:model}, assuming $n=2$ and $m=3$ from the metamodel in Figure~\ref{fig:metamodel}. The left side represents attributes, while the right side represents references. Each object (plus one \emph{dummy object}) gets a row. The attribute variables $a_{ij}$ are assigned the domain $\{lb, \ldots, ub\} \cup \{d\}$, and reference variables $ptr_{ij}$ are assigned the domain $\{1, \ldots, o\} \cup \{nullptr\}$ with $o=3$.

Model construction proceeds in two steps. First, we create matrices of variables with their full domains. Second, we instantiate some of these variables using data from the actual instance. In our current setting, we assign the exact values from the instance. Variables that remain uninstantiated may either be assigned dummy values or left free to explore during search, depending on the objective of the analysis.
\textcolor{black}{
To choose between these behaviors and to reduce the size of the CSP, in previous work we've proposed an annotation system for OCL \cite{coyle_towards_2025}, which allows the user to identify variables. 
These annotations split the OCL expressions into parts which can be dispatched between our CP interpretation, and that of a standard interpreter.
This reduces the scope and size of the CSP, notably in terms of modeled properties. 
}


% In Table \ref{tab:encoding} we can see the encoding resulting from the instance in Figure \ref{fig:model}, and the metamodel in Figure \ref{fig:metamodel} with $n=2$ and $m=3$.
% On the left we have the table encoding the attribute \inlineocl{attribute} of our objects of type \inlineocl{Object}, and on the right the table encoding the references.
% The number of columns is defined by $n$ and $m$, the choices of cardinality for these properties. 
% For each object there is a row in the table, and an additional row for the \emph{dummy object}.
% Building these tables in done in two steps, first the integer variable matrices are built. 
% The attribute variables $a_{ij}$ are given the domain $\{lb..ub\}\cup \{d\}$,
% and the reference variables $ptr_{ij}$ are given the domain $\{1..o\}\cup \{nullptr\}$ with $o=|Object|=3$.
% In a second phase, some variables are instantiated using the data from the instance.
% Here we instantiate them to the exact values found in the instance, but one could widen the domain allowing for small changes to be allowed.
% The remaining variables can be instantiated to their associated dummy value, allowing us to verify the model.
% Otherwise, such as here, they can be left with a whole domain, allowing us to try completing the model.
% To choose between these behaviors we intend to annotate the OCL as seen in \ytodo{cite previous work}.
% These variables are key to the problem, and will be the primary variables we test possible values for during search.
% The values in the domain of pointer variables identify rows of property tables.
% The domain of relation variables is generally small enough to be enumerated.
% Therefore, we give them accompanying variables counting the occurrences for each value of the domain.

% \begin{equation}\label{csp:seq_X2Y}
% \begin{cases}
% \forall Class_o.ref \in Class.reference\\
% \implies gcc(Class_o.ref, Class_o.refOcc)
% \end{cases}
% \end{equation}


% $$Class.ref = \{r_{00},...,r_{nm}\}$$
% $$Class.refOcc = \{occ_{00},...,occ_{nm}\}$$
% $$\forall r \in Class.ref,\;domain(r) = \{0..n'\}$$
% $$\forall occ \in Class.refOcc,\;domain(occ) = \{0..m\}$$
% $$\forall n :object \in Class,\; gcc(Class_o.ref, Class_o.refOcc)$$

% When two references are opposites, such as \emph{child} and \emph{parent}, we need to do stuff.

% $$\forall i,j \in \{0..n\}*\{0..n'\} A.refOcc_{ij},\neq 0 \iff B.oppOcc_{ji}\neq 0$$

% For containment 

% \subsection{CP model for OCL queries on the instance}\label{ssec:contrib_navigation}



\section{CP Models for UML Collection Types}\label{sec:contrib_enforcing_type}

As described in Section \ref{ssec:ctxt_cd}, properties in class diagrams (e.g., Figure \ref{fig:metamodel}) can be annotated with collection types: \inlineocl{Sequence}, \inlineocl{Bag}, \inlineocl{Set}, or \inlineocl{OrderedSet}. These types can be enforced through constraint models to ensure consistency and reduce symmetries in the data..

For \inlineocl{Sequence}, permutations of the same multiset (e.g., $\{1,1,2\}$) yield distinct sequences. However, in our encoding, sequences such as $\{1,2,d,1\}$ and $\{1,2,1,d\}$ are treated as equivalent, since they encode the same effective ordering of values (e.g., the position of the dummy value $d$ is ignored). To correctly model sequences, we impose an ordering where all dummy values are grouped at the end. 


Let $X=\{x_1,..,x_p\}$ be the variable array for a property in the matrix $=Class.property$. The \inlineocl{Sequence} constraint is defined as: 
%\begin{equation*}
$\mathit{Sequence}(X) \iff \forall i \in [1,p[, (x_i=d)\Rightarrow (x_{i+1}=d) $. 
%\end{equation*}
This ensures dummy values appear only at the end. We reformulate it using the \texttt{regular} global constraint applied to a Boolean mask $S = \{s_1, \dots, s_p\}$:
% where $s_i = \llbracket x_i \neq d \rrbracket$:
%This constraint can be reformulated using the regular global constraints, defined over an array of boolean variables $S=\{s_1,...,s_p\}$ functionally dependent on $X$:
\begin{equation}\label{csp:seq_X} \footnotesize
\mathit{Sequence}(X):
\begin{cases}
\mathit{regular}(S,\mathit{DFA})\\
% \text{where}\; s_i=\llbracket x_i\neq d\rrbracket, i \in [1,p]\\
s_i=\llbracket x_i\neq d\rrbracket\\
\end{cases}
\end{equation} 

The automaton $\mathit{DFA}$ (Figure \ref{fig:afd}) accepts patterns of the form $1^*0^*$, ensuring non-dummy values precede dummy ones. %The mask $S$ enforces this structure without introducing search over dummy placements.
Here, $S$ acts as a mask distinguishing actual values (1) from dummies (0) while avoiding symmetry.

% Here we use a regular expression constraint defined by the automaton named $\mathit{DFA}$ illustrated in Figure \ref{fig:afd} which accepts words of the form $1^*0^*$.
% The boolean array $S$ serves as a \emph{mask} for $X$, hiding the dummy value behind 0, and values behind 1.
\begin{figure}[!ht]
    \centering
    \includegraphics[trim={0 7 0 8},clip,width=0.5\linewidth]{Articles/ICTAI2025/figures/afd.pdf}
    \vspace{-0.7em}
    \caption{DFA packing dummy values for instance variables}
    \label{fig:afd}
\end{figure}

For the \inlineocl{Bag} and \inlineocl{Set} types, all permutations of values are considered equivalent. 
To remove ordering symmetries, we sort the values in decreasing order, effectively pushing dummy values to the end:
% When considering the types \inlineocl{Bag} and \inlineocl{Set}, all permutations of the values are equivalent.
% To eliminate these symmetries we simply enforce that the values are sorted in decreasing order, which also pushes the dummy values to the end.
\begin{equation}\label{csp:bag_X} \footnotesize
\mathit{Bag}(X):
\begin{cases}
\forall i\in[1,p[:x_i\geq x_{i+1}\\
\end{cases}
\end{equation}

To model \inlineocl{Set}, we additionally enforce uniqueness among non-dummy values. Indeed, the sequence $\{d,d,d\}$ would be interpreted as an empty set. To this end, we define a relaxed variant of the \texttt{alldifferent} global constraint: 
% $\mathit{alldifferent\_except\_d}(X) \\ \iff \forall \,i,j \,(i < j) \in [1,|X|], & \, (x_i \neq x_j) \, \vee \, (x_i=x_j=d)$
% In the case of \inlineocl{Set} we also must enforce that all the values are different, however we don't want this to apply to the dummy value.
% For instance $\{d,d,d\}$ would be interpreted as an empty set.
%To do this we define a variation on $\mathit{alldifferent\_except\_0}$.
\begin{equation*}\label{csp:alldiff_def} \small
\begin{aligned}
\mathit{alldifferent\_except\_d}(X) \\
\iff \forall \,i,j \,(i < j) \in [1,|X|], & \, (x_i \neq x_j) \, \vee \, (x_i=x_j=d)
\end{aligned}
\end{equation*}


\begin{equation}\label{csp:set_X} \footnotesize
\mathit{Set}(X):
\begin{cases}
\mathit{alldifferent\_except\_d}(X)\\
\mathit{Bag}(X)
% \forall i\in[1,p[:x_i\geq x_{i+1}\\
\end{cases}
\end{equation}

For \inlineocl{OrderedSet}, both value order and uniqueness matter. We combine the constraints used for \inlineocl{Sequence} and \inlineocl{Set}: dummy values must be packed at the end, and non-dummy values must be pairwise distinct. Formally:
% Finally for the type \inlineocl{OrderedSet} we reuse the constraints distinctive of \inlineocl{Sequence} and \inlineocl{Set}.
% \vspace{-0.3cm}
\begin{equation}\label{csp:ordset_X} \footnotesize
\mathit{OrderedSet}(X):
\begin{cases}
\mathit{alldifferent\_except\_d}(X) \\%\, \wedge \, 
\mathit{Sequence}(X)\\
\end{cases}
\end{equation}
This ensures a well-formed sequence without repetitions, where dummy values are ignored in uniqueness checks and appear only at the end of the array.  These CP encodings ensure that model properties respect their specified UML and OCL collection types, enabling correct interpretation and reducing symmetry in instance generation.

% \begin{table}
% \centering
% \begin{tabular}{|l|l|}
% \hline
%  Sequence & CSP \ref{csp:seq_X} \\ \hline
%  Bag & CSP \ref{csp:bag_X} \\ \hline
%  Set & $\geq$ \& All Different \\ \hline
%  Ordered Set & DFA \& All Different \\ \hline
% \end{tabular}
%     \caption{Constraints used to enforce collection type constraints upon instance variables}
%     \label{tab:prop_type_csp}
% \end{table}
