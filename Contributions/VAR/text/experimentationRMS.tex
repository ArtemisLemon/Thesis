\ytodo{Add this estimate: no refactoring, single interpreter, CharCSTR= 12k variables and constraints, applied to all tasks = 522k, +UMLCSP and the other constraints}

\subsection{Refactoring Expressions on our method}
In our running example, our instance will have 4 stages (S) and 43 task (T), directly taken from \cite{Wang2012-srms}. We infer 24 machines (M) from their constraint model.
In our annotation of \texttt{machines} we will choose 24 as the maximum cardinality of the reference, and thus have 24 pointer variables in the associated \texttt{AdjList}.
Notice that the combinatorial complexity of the problem is quite challenging, since there are around $2.10^{40}$ possible graphs satisfying these assumptions. Generating all graphs and checking the OCL constraints would be unfeasible.  
The full code for this problem instance is available online.\footnote{\url{https://github.com/ArtemisLemon/navCSP_RMSTaskConstraints}}
% Tasks are linked to at most one stage, so the reference is given an AdjLink variable with a single pointer variable.
% The reference from stage to machine is unbounded in the metamodel of \autoref{fig:uc_uml}, an upper bound will there for have to be defined in the annotation.
% In the original use case, the space constraint bounded this number to 6 for all stages, which will be the value used for times.
% In other measurements, this value will be a variable $N$.

% This work is also ... by previous work on ATLc, which provides an solving for OCL constraints on attributes. 
% In a way, providing human-in-the-loop optimisation, and domain space exploration.
% This requires fast solving.

\begin{table}[ht]
\begin{tabular}{|c|r|r|r|r|}
\hline
\multicolumn{1}{|l|}{\textbf{var()}} & \multicolumn{1}{l|}{\textbf{variables}} & \multicolumn{1}{l|}{\textbf{domain}} & \multicolumn{1}{l|}{\textbf{constraints}} & \multicolumn{1}{l|}{\textbf{time}} \\ \hline
\multirow{2}{*}{stage}                                                      & 43 & S & \multirow{2}{*}{(43)} & \multirow{2}{*}{0.1s}              \\ \cline{2-3}
                                                                            & 0 & M & & \\ \hline
\multirow{2}{*}{machines}                                                   & 0 & S & \multirow{2}{*}{(96)} & \multirow{2}{*}{0.1s}              \\ \cline{2-3}
                                                                            & 96 & M & &                                    \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}stage\\ machines\end{tabular}}   & 43 & S & \multirow{2}{*}{2064 (+1032)} & \multirow{2}{*}{0.3s}              \\ \cline{2-3}
                                                                            & 96+1032 & M &                                           &                                    \\ \hline
\end{tabular}
\caption{Size and resolution times of the refactored Expressions}
\label{tab:rms_results}
\end{table}

In \autoref{tab:rms_results} we find the metrics for the three RMS scenarios.
Additionally to the same characteristic constraint, we also enforce the precedence constraint in the scenarios where the reference \texttt{Task.stage} is annotated.    
The first column identifies the annotations, and the scenarii.
The second column gives the variable counts for each domain.
The variable count includes all variables (problem and intermediate) involved in the expression.
While the intermediate variable are unique to the model of this expression, the problem variables (tied to the instance objects) are shared by any other expression.
Domains, informed by the third column, are identified by their upper bound, as the lower bound generally 0 for pointer variables.
For the last row, we have both 96 problem variables of domain M, and because of the navigation from the 43 problem variables of domain S, each requiring their own copies of the variables of domain M, there are 1032 (43*N) intermediate variables.

In the constraints column, we count constraints of the OCL CSP, mainly element constraints and pointer arithmetic.
In between brackets is the counter of $member$ constraints.
As $member$ only propagates once, by default our solver doesn't include them in the constraint count.
As it is the only constraint in two of these cases, we have included them.

Finally for times, we can see this problem is trivial for the solver.
Most of the time taken is to build the model.

% \subsection{Base UseCase Expressions}
% \begin{table}[ht]
%     \begin{tabular}{|c|r|r|r|r|}
%     \hline
%     \multicolumn{1}{|l|}{\textbf{var()}} & \multicolumn{1}{l|}{\textbf{variables}} & \multicolumn{1}{l|}{\textbf{domain}} & \multicolumn{1}{l|}{\textbf{constraints}} & \multicolumn{1}{l|}{\textbf{time}} \\ \hline
%     \multirow{2}{*}{stage}                                                      & 43 & S & \multirow{2}{*}{(43)} & \multirow{2}{*}{0.1s}              \\ \cline{2-3}
%                                                                                 & 0 & M & & \\ \hline
%     \multirow{2}{*}{machines}                                                   & 0 & S & \multirow{2}{*}{(96)} & \multirow{2}{*}{0.1s}              \\ \cline{2-3}
%                                                                                 & 96 & M & &                                    \\ \hline
%     \multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}stage\\ machines\end{tabular}}   & 43 & S & \multirow{2}{*}{2064 (+1032)} & \multirow{2}{*}{0.3s}              \\ \cline{2-3}
%                                                                                 & 96+1032 & M &                                           &                                    \\ \hline
%     \end{tabular}
%     \caption{Size and resolution times of the starting expressions}
%     \label{tab:rms_results}
% \end{table}


\subsection{Refactoring Expressions in Alloy Models}

\begin{lstlisting}
    abstract sig Characteristic {}
    abstract sig Task { characteristics : set Characteristic,..}
    abstract sig Machine { characteristics : set Characteristic,..}
    
    abstract sig Stage {
        ..,
        tasks: seq Task,
        machines: seq Machine
    }
\end{lstlisting}
Here we have a stripped down Alloy specification of the RMS metamodel.
\ytodo{to be as close to our model, sequence variables \inlineocl{seq} are used for the problem variables, Task<->Stage<->Machines, and sets (which are much more efficient) are used for part of the constraint expression we interpret before building the CSP}

\begin{lstlisting}
    fact MachineContainment {
        all s1,s2 : Stage | s1!=s2 => s1.machines.elems & s2.machines.elems=none
    }

    fact OppositeTaskStage {
        all t : Task | t in t.stage.tasks.elems
        all s : Stage | s = s.tasks.stage.elems
    }
\end{lstlisting}
These two facts model the notions of UML Containment and Opposite relations.
The containment constraint states \textit{for any two stages, if they are different then the intersection of their respective sets of machines is empty}.
The opposite constraint comes in two parts.
The first one states \textit{for any task, the stage its associated to, is associated to it}.
The second one states \textit{for any stage, the tasks its associated to, are each associated to it}.

\begin{lstlisting}
    one sig Stage10 extends Stage{} {ID=10 maxMachines=3}
    one sig Stage20 extends Stage{} {ID=20 maxMachines=3}
    one sig Stage30 extends Stage{} {ID=30 maxMachines=3}
    one sig Stage40 extends Stage{} {ID=40 maxMachines=3}
\end{lstlisting}
Along with the alloy specification of the metamodel, we can specify a partial model.
In this listing we input the existing model data, by defining a class (signature) for each object instance.
The object will be the only instance of its distinct subclass (defined by the known data), which inherits from its class.

\begin{lstlisting}
    // 2994706 vars. 17315 primary vars. 10035908 clauses. 5409ms.
    // Instance found. Predicate is consistent. 7393ms.
    fact SameCharacteristicConstraint{
        all t: Task | t.characteristics in t.stage.machines.characteristics.elems
    }
\end{lstlisting}
\begin{lstlisting}
    // 2749262 vars. 17315 primary vars. 9551642 clauses. 4812ms.
    // Instance found. Predicate is consistent. 2427ms.
    fact SameCharacteristicConstraint_Refactored{
        all t: Task | t.stage.machines.elems in { m:Machine | t.characteristics in m.characteristics }
    }
\end{lstlisting}
In the two listings above, we have both forms of the \textit{same characteristic constraint}, and the solver output as comment.
The variable and clause count of the output includes the rest of the model, such as the \textit{precedence constraint}, and UML specific constraints such as the \textit{UML Opposite Relation}, \textit{UML Containment Relation}.
Without this constraint the model has 2611962 vars, 17315 primary vars, and 9305982 clauses.
Meaning the first version of the expression requires 382744 vars and 9105316 clauses,
The refactored version of the expression requires 137300 vars and 8621050 clauses, which is 245444 vars and 484266 clauses less than the original, 5.3\% the original number of variables and 94.6\% of the original number of clauses.

Most notable is the time difference, the first version of the expression takes around 8 seconds to solve, while refactored version around 3 seconds.
The times in the comments are the best times among a few reruns.