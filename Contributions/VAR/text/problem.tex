For illustrative purposes, throughout the paper we exemplify the method on a well-known example, about Reconfigurable Manufacturing Systems (RMS). Notice however that the way to enforce constraints presented in this paper can be applied to any class diagram with OCL constraints. 

\subsection{Reconfigurable Manufacturing Systems}
% \ytodo{Explain UML and OCL without any notions of .var()}
An RMS \cite{Koren1999-rms} is an industrial solution to the problem of varying product demand.
In the most common version of the problem (from~\cite{Wang2012-srms}), a factory is organised into subsequent stages of identical machines.
To change the productivity of the factory, machines are added and removed from stages.
Manufacturing tasks are allocated to stages, and are generally at least partially ordered.
RMSs provide a number of problems to solve, such as:
matching tasks and machines with stages,
optimising those matches to achieve new productivity goals, 
as well as allocating the products to a machine of the stage it's going through,
or planning machine maintenance.

% \ttodo{these next sentences are very dry and disjoint}

% From this example we will take a structural constraint, to consider how to solve for it.
% % In this example we focus on the structural aspect of constraints of an RMS. 
% (constraints on attributes have already been studied in previous work \ynote{\cite{lecalvar_coupling_2021,le_calvar_toward_2019}}{I removed Petter from here, because they do it with logic}). 
% \ytodo{Theo: We focus our example on structural constraints that were not supported in our previous work. (was suggested before we realised it's double blind)}
% % Thus, we omit constraints that affect exclusively object attributes.
% In these examples, constraints are written with OCL queries which can be split in a variable and a constant parts.
% These constant parts are used as source for variable parts, when these variables affect references we call them variable references.

% These type of constraints use queries, which may present deterministic and variable portions, to find attributes and references upon which to to be applied.
% The variables and constraints of these problems pertain to OCL collections and their operations, in the specific case they represent References.
% The sources of the variable portion of queries are variable references, which are a particular case of OCL collections.

\begin{outline}
% \1 RMS
    % \2 what is reconfigurable manfacturing systems?
    % \2 \cite{wang_scalability_2012} example

% \1 UML model inspired from example
    % \2 changes are to illustrate contributions
        % \3 deeper navigation
    % \2 instance keeps the same task precedence tree and number of stages, gives a problem size

% \1 OCL Constraints(Expressions) inspired from example
    % \2 Same Characteristic Constraint
    % \2 Precedence Constraint
    % \2 Stage Size Constraint
    % \2 Budget Constraint
 
    % \2 cardinality constraints
    %     \3 a.b.c.size < 12
    %     \3 stage.tasks.size < 14
    %     \3 configuration.stages.tasks.size < 140
    %     \3 configuration.stages.machines.sum < 140 \ytodo{not a structural constraint}
    % \2 includes (making cycles/patterns)
    %     \3 a.var(c)->includesAll(a.var(b).var(c))
    %     \3 RMS Characteristic Constraint
    %     \3 stage.characteristics->IncludesAll(stage.var(tasks).characteristics)
    %         \4 this is like \cite{wang_scalability_2012}
    %         \4 but we could add more variables
% \1 general OCL problems
%     \2 Structural OCL Constraints
    % \2 mixing variable and deterministic navigation?
%     \2 Collection Constraints
\end{outline}


\subsubsection{A Class Diagram for RMS}
\begin{figure}[t]
\includegraphics[trim={0 0 0 0},scale=0.8]{Articles/SAC2025/figures/uc_uml.pdf}
\caption{Class Diagram for RMS Task constraints} \label{fig:uc_uml}
\Description[class diagram of RMS]{}
\end{figure}

\autoref{fig:uc_uml} uses a class diagram to describe the concepts of an RMS, and how they relate (inspired by~\cite{Wang2012-srms}). In this figure, we focus on the graph structure of the model (classes and references among them), omitting attributes. We use the class diagram flavor from the Eclipse Modeling Framework (EMF)\footnote{\url{https://eclipse.dev/modeling/emf/}}, that connects classes by unidirectional \emph{references}, instead of bidirectional \emph{associations}. 

% \footnote{In the use case we're taking inspiration from, all the machines had the same characteristics. We chose an arbitrary number of characteristics to illustrate possible sizes of the resulting CSPs.}
%From it we take 
%the number of stages and tasks to get information about problem sizes, 
%the task precedence tree,
%and an estimate number of machines.
% Larger than the number of stages, smaller than the number of machines.
% equal to the max cardinality of our problem. 
% \ttodo{last two sentences read weird ?}
% \ttodo{I don't understand last part of this sentence}
% Because of the constant nature of the relations linking tasks, machines and characteristics, the optimal implementation doesn't ask the CP solver to compute those matches. 
% In light of this, for our particular use case,  the number of characteristics doesn't have to effect the final size of the CSP. 
% \ttodo{werll, this could be rewritten in a simpler way}

The two main components of a reconfigurable manufacturing system are stages, and machines which are organised into stages.
% Stages have three properties of which two are attributes (stageId and maxMachines) and one is a containment reference to machines.
% Stages are totally ordered and have a numeric label to materialise it, the stageID.
% Common practice in RMS is to label them 10, 20, and so on.
% Thus we represent it as an attribute.
% Additionally, each stage has a maximum number of machines.
A \texttt{Machine}'s property is its relation to a set of \texttt{Characteristics}.
% and for each machine a cost attribute.
% All the machines of a stage must share the same characteristics.
Objects of type \texttt{Task} are partially ordered, as expressed by the \texttt{prev} reference.
%, this order introduces precedence constraints, not addressed here.
% modeled by the prev reference.
% Which  to our problem.
Tasks have two other properties: a reference to a \texttt{Stage} (allocating the task to that stage), and a reference to characteristics (i.e., the machine characteristics needed to perform the task). Similarly to the example in \cite{Wang2012-srms}, tasks and machines can be linked to any number of characteristics.

\subsubsection {OCL Constraints for RMS}

\begin{listing}
\begin{lstlisting}[language=ocl]
context Task inv SameCharacteristicConstraint: 
    self.stage.machines.forall(m | m.characteristics
        ->includesAll(self.characteristics)) 

context Task inv PrecedenceConstraint: 
    self.stage.stageNum >= self.prev.stage.stageNum
\end{lstlisting}
\caption{RMS Task constraints in OCL.} \label{lst:uc_ocl}
\end{listing}

The class diagram shown in \autoref{fig:uc_uml} cannot encode all constraints that are required for an instance to be a correct RMS instance.
%Some of the qualities of an RMS cannot be described with the pure UML Class Diagram of \autoref{fig:uc_uml}.
Additional constraints can be specified using OCL. 

\autoref{lst:uc_ocl} shows the two constraints we use as running example in this paper.
These are the structural constraints for tasks, part of a more detailed constraint model for RMS, with budget and productivity constraints.

OCL provides a way to query a model. 
For a given object, or collection of objects, we can query properties using "\texttt{.}", in expressions following an $objects.property$ pattern. 
Their properties can be references or attributes. 
In our running example, tasks have a reference to a stage, named \texttt{stage}, representing the stage a task is assigned to. In the OCL in \autoref{lst:uc_ocl} line 2, from the context of a \texttt{Task}, we query its \texttt{stage} by the expression \texttt{self.stage}.
The sub-expression \texttt{self} resolves to an individual object of type \texttt{Task}. 
The whole expression resolves to another object, of type \texttt{Stage}, associated with the task.
We can see this as a navigation starting at a \texttt{Task} node, and traversing the reference to the associated \texttt{Stage} node. We can chain navigations: e.g. to find the machines of the stage of a given task in \autoref{lst:uc_ocl} line 2 we use 
\texttt{self.stage.machines}.
% In this example we can see 
%OCL provides a language to query the model, and operations to apply on the results of the queries.
%In these constraints the \emph{top level} operations ($<$, $includesAll$, $forall$, $sum$,...) describe constraints on the queries \emph{below}.
%To navigate the model in a query, OCL uses navigation or attribute calls, which can be chained.
%In the OCL expressions of autoref{lst:uc ocl}, the operation is symbolised by ".", for example in $stage.machines$.
% \mtodo{This is ATLc flavor of OCL, give a short description}
% \ttodo{add line numbers from listing to each constraint paragraph?}
% \texttt{StageSizeConstraint} (\autoref{lst:uc_ocl}, \autoref{lst:ocl:var:size}) limits the number of machines that can be assigned to a stage.
% Because each stage can have a different value for $maxMachines$, this constraint cannot be represented using an upper bound on the cardinality of the machines reference.
% %In the class diagram we cant detail the cardinality for the individual stages, but that information is available as attribute of the stage object.
% %Thus we limit the size of the collection representing the links of the reference.

\texttt{SameCharacteristicConstraint} ensures that \emph{the machines of the stage performing a task} have all the required characteristics. From the given task (\texttt{self}) we navigate to the stage where it is performed, and find all the machines of that stage (\texttt{self.stage.machines}). For each machine \texttt{m} we impose that the set of \texttt{characteristics} it supports  (\texttt{m.characteristics}) includes all the characteristics required by the given task (\texttt{self.characteristics}).

\texttt{PrecedenceConstraint} ensures that tasks with precedence are performed after their predecessors, i.e. they are assigned to the same stage or a later one.\footnote{The constraint uses the \texttt{stageNum} constant integer attribute that indicates the position of the stage in the manufacturing line, omitted in \autoref{fig:uc_uml}.}
%\footnote{In our model for brevity, the order of the pointer variable domains corresponds to the order of stages in the instance. In the more detailed model, a constant attribute of \texttt{Stage}: \texttt{stageID} represents the order among stages.\mtodo{I would prefer to add stageID to the metamodel and constraint, or just remove PrecedenceConstraint, that is never used}}
% \mtodo{add explaination for readers that do not know OCL}

We will consider these constraints in the following three scenarios.
\begin{description}
    \item[S1:] machines have already been assigned to stages, and the assignment of tasks to stages must be found;
    \item[S2:] tasks have already been assigned to stages, and the assignment of machines to stages needs to be found;
    \item[S3:] both tasks and machines must be assigned to stages.
\end{description}
%To identify these different scenarios
% , possibly with additional information to model the problem.
%we propose annotations in the OCL, described in \autoref{ssec:sac2025:varop}.
% \ynote{
% In the larger scope of our work, the OCL is written as part of an ATL transformation, and work under the assumption a variety of transformations can/will be applied to a model.
% % In the context of model exploration, we often have to find new information, such as the position of an object instance in a graphical user interface resulting from a transformation.
% }{maybe move to discussions}

% for the task to be performed.
% The third constraint describes the relation between a task and the machines of the stage it's associated to.
% All the machines of the stage associated to a task must fit the task's characteristics requirements.

% \texttt{BudgetConstraint} (\autoref{lst:uc_ocl}, \autoref{lst:ocl:var:budget}) describes a budget constraint stating that the total cost of machines of all the stages stays below a given threshold.%, an arithmetic constraint on the sum cost of the used machines.
% % \ttodo{\ytodo{Because budgets are sometimes exceeded, in the implementation we will introduce constraint relaxation here}}
